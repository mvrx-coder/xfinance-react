 Tela “Performance” (renomeada de Financial)

Leia e aplique este contexto antes de qualquer implementação:
Projeto: xFinance 3.0 — migração do frontend para React/TypeScript + FastAPI.
Banco: SQLite (xFinanceDB.db) do sistema original; manter nomenclaturas alinhadas ao schema e às queries atuais.
Regras: não alterar estética/tema (glassmorphism, lilás/ciano, gradientes), não mudar estrutura de componentes, não mexer nas animações Framer Motion, não adicionar/remover dependências, usar Radix UI conforme já adotado.
Renomeação oficial: a tela “Financial” passa a se chamar “Performance” e deve ser registrada na documentação.
Objetivo

Implementar a página “Performance” com visual premium, compatível com o restante do sistema, e preparada para integração com FastAPI/SQLite.
Pesquisar referências visuais de “premium glassmorphism analytics dashboards”, “Radix UI filters + cards”, “Framer Motion micro-interactions” e aplicar os padrões compatíveis com nosso tema.
Entregáveis

Página PerformancePage acessível por "/performance" sem alterar a estrutura existente.
Componentes:
PerformanceFilters (filtros de período e domínio)
PerformanceKpiCards (KPI cards com skeleton loading)
PerformanceCharts (gráficos principais)
PerformanceDetailsTable (lista detalhada filtrada)
Tipos TypeScript em src/types/performance.ts.
Serviços de API em src/services/api/performance.ts e lookups em src/services/api/lookups.ts (stubs inclusos).
Atualização de rotas/menus: substituir rótulos “Financial” por “Performance” sem alterar estilos.
Atualização de documentação do frontend: registrar a renomeação e pontos de integração.
Filtros e Nomenclaturas

Filtros padrão (usar exatamente estas chaves no estado e nos payloads):
anos: number[] (ex.: [2024, 2025])
id_uf?: number
id_cidade?: number
id_contr?: number
id_segur?: number
id_ativi?: number
periodo?: { inicio?: string; fim?: string } (ISO YYYY-MM-DD)
Comportamento:
UF habilita Cidade e filtra opções.
Anos inicializa com ano corrente.
Todos filtros são opcionais; aplicar defaults prudentes.
Lookups:
fetchUfOptions() → { value: id_uf, label: uf_sigla }
fetchCidadeOptions(id_uf) → { value: id_cidade, label: cidade_nome }
fetchContrOptions(), fetchSegurOptions(), fetchAtiviOptions() → { value: id, label: nome }
Tipos TypeScript (src/types/performance.ts)

interface PerformanceFilters { anos: number[]; id_uf?: number; id_cidade?: number; id_contr?: number; id_segur?: number; id_ativi?: number; periodo?: { inicio?: string; fim?: string } }
interface KpiSummary { total_trabalhos: number; total_honorarios: number; total_despesas: number; margem_liquida: number; crescimento_anual?: number }
interface ChartPoint { x: string | number; y: number; group?: string }
interface ChartSeries { name: string; points: ChartPoint[] }
interface PerformanceData { kpis: KpiSummary; market: ChartSeries[]; business: ChartSeries[]; operational: ChartSeries[]; details: any[] }
Serviços de API (src/services/api/performance.ts)

Base URL: import.meta.env.VITE_API_URL com fallback "/api".
Funções:
async function fetchKpis(filters: PerformanceFilters): Promise<KpiSummary>
async function fetchMarket(filters: PerformanceFilters): Promise<ChartSeries[]>
async function fetchBusiness(filters: PerformanceFilters): Promise<ChartSeries[]>
async function fetchOperational(filters: PerformanceFilters): Promise<ChartSeries[]>
async function fetchDetails(filters: PerformanceFilters): Promise<any[]>
Stubs locais (sem libs novas):
Retornar Promise.resolve com dados simulados quando backend não disponível.
Não logar dados sensíveis; logs mínimos e genéricos.
UI/UX Premium

Container glassmorphism com blur, sombras suaves e cabeçalho lilás/ciano com gradiente consistente.
Layout:
Header com título “Performance” e resumo dos filtros ativos.
Linha de filtros com Radix UI (Select, DatePicker ou inputs), a11y e estados de loading.
Grid de KPI Cards com skeleton e micro-interações (Framer Motion).
Seção de gráficos:
“Business” (ex.: evolução por dt_*, honorários vs despesas)
“Market” (ex.: distribuição por atividade, segur, contr)
“Operational” (ex.: volumetria por uf, cidade)
Tabela de detalhes com paginação e ordenação local (não alterar lógica global).
Interações:
Debounce simples de filtros (200–400ms) sem libs extras.
Loading states consistentes; feedback em Toast para erros de API.
Acessibilidade: labels, aria-*, foco visível, navegação por teclado.
Validações e Comportamento

Filtros:
anos: validar números (≥ 2000); default inclui ano atual.
periodo: se ambos fornecidos, inicio <= fim.
id_cidade só permitido quando id_uf definido.
Ciclo de dados:
Ao alterar filtros, recarregar KPIs e gráficos com debounce.
Tabela de detalhes atualiza por último para sensação de fluidez.
Performance:
Evitar recomputações; utilizar memoização leve para séries no cliente quando reusadas.
Padrão Visual e Estrutura

Reutilizar tokens de cores/gradientes já existentes.
Não alterar CSS global, nem mover pastas, nem quebrar componentes.
Responsivo: mobile-first; cartões em coluna única no mobile e em grid 2–3 colunas no desktop.
Aceitação

Página compila sem novas dependências.
Filtros operam com dependências corretas e a11y.
KPI cards e gráficos renderizam com stubs.
Payloads de filtros usam exatamente as chaves definidas.
Tema e animações preservados.
Mapeamento Futuro FastAPI/SQLite

Endpoints sugeridos (compatíveis com queries existentes em finance):
POST /performance/kpis → agrega sobre princ (honorario, despesa, contagem), respeitando filtros.
POST /performance/market → séries por atividade, segur, contr.
POST /performance/business → séries temporais por dt_* (ex.: dt_inspecao).
POST /performance/operational → volumetria por uf, cidade.
POST /performance/details → lista detalhada filtrada (paginada no backend opcionalmente).
Filtros no backend devem aceitar chaves idênticas às do frontend (anos, id_uf, id_cidade, id_contr, id_segur, id_ativi, periodo).
Registro de Renomeação (Documentação)

Atualizar documentação do frontend e notas de migração:
Criar/atualizar docs/performance.md no projeto React com:
Título: “Tela Performance (renomeada de Financial)”
Rotas: "/performance" e componentes entregues
Filtros e payloads suportados
Endpoints de API e formato dos dados
Nota de compatibilidade: “Financial” → “Performance” (menus, breadcrumbs, rotas)
Atualizar README interno da feature:
Como trocar stubs pelos endpoints FastAPI sem alterar a UI
Lista de lookups e dependências visuais
Atualizar navegação/menus e breadcrumbs:
Substituir rótulos “Financial” por “Performance” mantendo estilos e animações.
Observações Finais

Não criar nem remover dependências.
Preservar a estética glassmorphism, lilás/ciano e micro-interações do Framer Motion.
Entregar o código pronto para colagem nos caminhos indicados, com stubs funcionais e documentação de troca para FastAPI.
Central de Ações (Drawer Premium)

- Leia e aplique este contexto antes de qualquer implementação:
  
  - Projeto: xFinance 3.0 — migração do frontend para React/TypeScript + FastAPI.
  - Banco: SQLite ( xFinanceDB.db ) do sistema original; manter nomenclaturas alinhadas com o schema atual para reaproveitar queries.
  - Regras: não alterar estética/tema (glassmorphism, lilás/ciano, gradientes), não mudar estrutura de componentes, não mexer nas animações Framer Motion, não adicionar/remover dependências, usar Radix UI conforme já adotado.
- Objetivo:
  
  - Implementar a Central de Ações como um drawer premium, funcional e compatível com a migração do frontend, integrada ao grid e aos registros princ .
  - Pesquisar referências visuais de “premium glassmorphism action drawers”, “Radix UI drawer/panel patterns”, “Framer Motion micro-interactions” e aplicar padrões compatíveis com o tema.
- Entregáveis:
  
  - Componente ActionCenter (drawer) com seções dinâmicas: Encaminhar , Marcadores , Excluir , Filtros .
  - Barra de botões ActionButtons integrada ao grid, com estados habilitado/desabilitado conforme seleção.
  - Tipos TypeScript em src/types/acoes.ts .
  - Serviços de API em src/services/api/acoes.ts com stubs para futura conexão FastAPI.
  - Store de seleção em src/stores/selection.ts (ou reutilizar a store existente do grid).
  - Não criar novas dependências; usar Radix UI, Framer Motion e fetch .
- Contexto de seleção:
  
  - Todas as ações operam sobre ids_princ selecionados no grid ( id_princ ).
  - Desabilitar botões quando ids_princ.length === 0 .
  - Exibir contadores e feedback ao usuário sobre a seleção atual.
- Ações e nomenclaturas — usar exatamente estas chaves nos estados e payloads:
  
  - Encaminhar (encaminhamento de inspeções)
    - Entrada: ids_princ: number[] , id_user_destino: number , obs?: string
    - Efeito: atualizar atribuição em princ (ex.: id_user_guy ou id_user_guilty ), mantendo consistência com o backend.
    - Lookups: usuários vêm da tabela user ( id_user , nome , papel , ativo ).
  - Marcadores (alertas/flags visuais)
    - Entrada: ids_princ: number[] , marker_type: MarkerType , value: boolean , obs?: string
    - Persistência: via função compatível com save_marker_state no backend.
    - type MarkerType = 'urgente' | 'pendente' | 'auditoria' | 'followup'
  - Excluir (remoção de registros)
    - Entrada: ids_princ: number[] , confirmação de segurança
    - Operação: deleção em princ com tratamento de FK (backend valida).
  - Filtros (limpar filtros do grid)
    - Efeito: limpar filtros do grid no frontend e notificar backend via stub (opcional).
- Tipos TypeScript ( src/types/acoes.ts ):
  
  - type MarkerType = 'urgente' | 'pendente' | 'auditoria' | 'followup'
  - interface EncaminharInput { ids_princ: number[]; id_user_destino: number; obs?: string }
  - interface MarcadorInput { ids_princ: number[]; marker_type: MarkerType; value: boolean; obs?: string }
  - interface ExcluirInput { ids_princ: number[] }
  - interface AcaoResult { success: boolean; updated?: number; deleted?: number; message?: string }
- Serviços de API ( src/services/api/acoes.ts ):
  
  - Base URL: import.meta.env.VITE_API_URL com fallback "/api" .
  - async function encaminhar(input: EncaminharInput): Promise<AcaoResult>
  - async function marcar(input: MarcadorInput): Promise<AcaoResult>
  - async function excluir(input: ExcluirInput): Promise<AcaoResult>
  - async function limparFiltros(): Promise<{ success: boolean }>
  - Stubs locais sem libs extras:
    - Retornar Promise.resolve com resultados simulados ( updated , deleted ) quando o backend não estiver disponível.
    - Nunca logar dados sensíveis; logs mínimos e genéricos.
- Lookups auxiliares ( src/services/api/lookups.ts ):
  
  - fetchUsersOptions() : retorna { value: id_user, label: nome, papel, ativo }
  - fetchMarkerTypes() : retorna os tipos de MarkerType para preencher o UI.
- UI/UX premium:
  
  - Drawer glassmorphism com blur, sombras suaves e cabeçalho lilás/ciano com gradiente consistente.
  - Seções do drawer:
    - Encaminhar : Select de usuário destino, Textarea de observação, resumo da quantidade de itens selecionados.
    - Marcadores : lista de toggles ( Switch / Checkbox ) para cada MarkerType , com contagem de aplicáveis.
    - Excluir : texto de confirmação, contador e botão com estado de danger .
    - Filtros : botão “Limpar filtros” com confirmação leve (Dialog).
  - Radix UI: Dialog / Drawer , Select , Switch / Checkbox , Toast para feedback.
  - Framer Motion: micro-interações — entrada do drawer, transições das seções, confirmação com leve escala/fade.
  - Acessibilidade: labels, aria-* , foco visível, navegação por teclado.
- Comportamento dos botões:
  
  - Encaminhar : habilita somente se houver seleção; após sucesso, toast “Registros encaminhados” e opção de fechar drawer.
  - Marcadores : aplica em lote; feedback por tipo marcados/limpos.
  - Excluir : requer confirmação explícita; exibe progresso e resultado.
  - Filtros : limpa filtros do grid e reseta paginação/local sort no frontend.
- Integração com o grid:
  
  - ActionButtons lê ids_princ da store do grid ( src/stores/selection.ts ).
  - Atualiza contadores no rótulo dos botões e no cabeçalho do drawer.
  - Não alterar a estrutura do grid; apenas consumir a seleção e emitir eventos.
- Validações no frontend:
  
  - Encaminhar : exigir id_user_destino válido; desabilitar envio sem seleção.
  - Marcadores : impedir envio sem seleção; exibir estados por tipo.
  - Excluir : impedir envio sem seleção; confirmação obrigatória.
  - Filtros : sempre permitido; confirmação leve.
- Padrão visual e estrutura:
  
  - Reutilizar tokens de cores e gradientes do projeto.
  - Não alterar CSS global, não mover pastas, não quebrar componentes.
  - Responsivo: mobile-first; drawer ocupa tela inteira em mobile, largura moderada em desktop.
- Aceitação:
  
  - Drawer e botões funcionam sem novas dependências.
  - Estados de habilitação e contadores refletem a seleção do grid.
  - Feedback com toasts e micro-interações operando conforme esperado.
  - Payloads usam exatamente as chaves definidas ( ids_princ , id_user_destino , etc.).
  - Stubs de API prontos; futura troca para FastAPI será apenas de URL/rotas.
- Mapeamento futuro FastAPI/SQLite (não codar migração agora):
  
  - POST /acoes/encaminhar → atualiza princ.id_user_guy ou princ.id_user_guilty conforme critério do backend; opcionalmente registra obs .
  - POST /acoes/marcar → persiste estado por id_princ em storage de marcadores, compatível com save_marker_state .
  - POST /acoes/excluir → remove registros de princ por id_princ , com validação de FKs.
  - POST /grid/filtros/limpar → opcional; front-end já limpa localmente, backend pode registrar evento.
  - Lookups:
    - GET /lookups/users → opções de usuários ( id_user , nome , papel , ativo ).
    - GET /lookups/markers → tipos de marcadores.
- Entregar o código pronto para colagem, nos caminhos indicados, e incluir no README interno da feature instruções rápidas de como trocar os stubs pelas chamadas reais ao FastAPI sem alterar a UI.
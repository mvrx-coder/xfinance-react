Alinhar registros princ (FKs id_*, meta, ms) e formular “Novo Trabalho”

Leia e aplique este contexto antes de qualquer implementação:

Projeto: xFinance 3.0 — React/TypeScript + FastAPI, alinhado ao SQLite (xFinanceDB.db).
Regras: não alterar estética/tema (glassmorphism, lilás/ciano, gradientes), não mudar estrutura de componentes, não mexer nas animações Framer Motion, não adicionar/remover dependências, usar Radix UI conforme já adotado.
Objetivo:

Alinhar o schema e os tipos do frontend para usar FKs e campos reais da tabela princ, garantindo compatibilidade com o banco e reaproveitamento de queries.
Ajustar o formulário “Novo Trabalho” e o DataGrid para trabalhar com FKs (id_*) e exibir rótulos via lookups.
Entregáveis:

Atualizar shared/schema.ts (apenas a parte de inspections) para refletir princ:
Remover campos denormalizados uf, cidade, player, segurado, nickGuilty, nickGuy, sw.
Adicionar FKs e inteiros:
idContr: integer("id_contr")
idSegur: integer("id_segur")
idAtivi: integer("id_ativi")
idUf: integer("id_uf")
idCidade: integer("id_cidade")
idUserGuy: integer("id_user_guy")
idUserGuilty: integer("id_user_guilty")
meta: integer("meta")
ms: integer("ms")
Manter datas e valores:
dtInspecao, dtAcerto, dtEnvio, dtPago, dtEntregue, dtDenvio, dtDpago como text(...)
honorario, despesa, guyHonorario, guyDespesa como real(...)
obs: text("obs"), prazo: integer("prazo"), atividade: text("atividade")
Atualizar insertInspectionSchema para omitir idPrinc e aceitar os novos campos de FKs.
Criar lookups em client/src/services/api/lookups.ts:
fetchUfOptions(): Promise<Array<{ value: number; label: string }>>
fetchCidadeOptions(idUf: number): Promise<Array<{ value: number; label: string }>>
fetchContrOptions(): Promise<Array<{ value: number; label: string }>>
fetchSegurOptions(): Promise<Array<{ value: number; label: string }>>
fetchAtiviOptions(): Promise<Array<{ value: number; label: string }>>
fetchUsersOptions(): Promise<Array<{ value: number; label: string; papel: string; ativo: boolean }>> (reusar stub existente se já houver)
Stubs locais retornam arrays simulados; sem novas dependências.
Atualizar client/src/components/dashboard/modals/NewRecordModal.tsx:
Inputs base: id_contr, id_segur, id_ativi, id_uf, id_cidade (dependência UF → Cidade), dt_inspecao.
Campos opcionais: honorario, despesa, prazo, obs, flags meta (1/0), ms (0/1), e atribuições id_user_guy, id_user_guilty.
Envio de payload com chaves exatamente iguais às do banco (id_contr, id_segur, id_ativi, id_uf, id_cidade, etc.).
Validar obrigatórios: id_contr, id_segur, id_ativi, id_uf, id_cidade, dt_inspecao; números ≥ 0.
Atualizar client/src/components/dashboard/DataGrid.tsx:
Colunas que mostram rótulos devem consumir lookups:
Exibir UF e Cidade usando id_uf/id_cidade → label via lookup.
Exibir Contratante, Segurado, Atividade com labels a partir dos respectivos id_*.
Exibir “Guy”/“Guilty” com labels a partir de id_user_guy/id_user_guilty.
Manter paginação/edição e lógica existente; apenas trocar leitura dos rótulos.
Atualizar qualquer uso residual de campos antigos no Dashboard:
Substituir referências de player, segurado, uf, cidade, nickGuilty, nickGuy, sw por FKs e labels via lookups.
Não alterar comportamento de toasts e filtros já definidos.
Regras de compatibilidade:

Não alterar UI/estilos; apenas o mapeamento de dados e DTOs.
As funções de busca/refresh (onSearch) continuam iguais; o carregamento de labels é feito ao montar o grid ou on-demand.
atividade (texto) pode ser preenchida automaticamente com o label escolhido de id_ativi ao salvar, mantendo id_ativi como fonte de verdade.
Aceitação:

Build compila sem novas dependências.
Formulário “Novo Trabalho” salva com FKs corretos.
Grid exibe rótulos corretos via lookups e mantém funcionalidades.
Payloads usam exatamente as chaves de princ (id_*, meta, ms, datas e valores).
Nenhuma quebra visual ou mudança de estrutura de componentes.